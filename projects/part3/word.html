<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ink Character · 战</title>
  <style>
    :root{
      --paper:#f7f2e7;
      --paper2:#efe6d6;
      --ink:#0f0f10;
      --muted: rgba(20,20,20,.58);
      --card: rgba(255,255,255,.60);
      --stroke: rgba(0,0,0,.10);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:grid;
      place-items:center;
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, "Segoe UI", Arial,
                   "PingFang SC","Hiragino Sans GB","Noto Sans CJK SC","Microsoft YaHei";
      background: linear-gradient(180deg, var(--paper), var(--paper2));
      overflow:hidden;
    }

    .stage{
      width:min(1100px, 92vw);
      height:min(720px, 90vh);
      position:relative;
      border-radius:32px;
      overflow:hidden;
      box-shadow: 0 28px 70px rgba(0,0,0,.18);
      background: rgba(255,255,255,.18);
    }

    /* animated ink painting layer */
    canvas#bg{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      z-index:0;
    }

    /* rice paper fibers + vignette on top of canvas */
    .paperOverlay{
      position:absolute;
      inset:0;
      z-index:1;
      pointer-events:none;
      background:
        radial-gradient(1200px 900px at 20% 20%, rgba(90,70,40,.10), transparent 62%),
        radial-gradient(900px 700px at 78% 76%, rgba(30,60,90,.08), transparent 60%),
        linear-gradient(0deg, rgba(0,0,0,.03), transparent 22%, rgba(0,0,0,.02) 55%, transparent 85%),
        repeating-linear-gradient(90deg, rgba(40,30,15,.020) 0 1px, transparent 1px 7px),
        repeating-linear-gradient(0deg, rgba(40,30,15,.014) 0 1px, transparent 1px 9px),
        radial-gradient(closest-side at 50% 50%, transparent 68%, rgba(0,0,0,.10) 100%);
      mix-blend-mode:multiply;
      opacity:.85;
    }

    .topline{
      position:absolute;
      top:18px; left:22px; right:22px;
      display:flex;
      justify-content:space-between;
      gap:12px;
      color:var(--muted);
      letter-spacing:.12em;
      font-size:12px;
      text-transform: uppercase;
      user-select:none;
      z-index:3;
      pointer-events:none;
    }
    .topline b{
      color:rgba(0,0,0,.70);
      letter-spacing:.10em;
      font-weight:650;
    }

    .center{
      position:absolute;
      inset:0;
      display:grid;
      place-items:center;
      z-index:2;
    }

    svg{
      width:min(760px, 82vw);
      height:auto;
      max-height: 86vh;
    }

    .calligraphy{
      font-family: "LiSu","STLiti","KaiTi","STKaiti","FangSong","SimSun",serif;
      font-size: 520px;
      font-weight: 400;
    }
    .ink-base{
      fill: rgba(12,12,12,.92);
      filter: drop-shadow(0 18px 26px rgba(0,0,0,.22));
      user-select:none;
    }

    .layer{
      opacity:0;
      transition: opacity .14s ease;
      user-select:none;
    }
    .layer text{
      transform-origin: var(--ox, 500px) var(--oy, 350px);
      transition: transform .20s ease, opacity .20s ease;
      opacity: .98;
    }
    .layer.on{ opacity: 1; }
    .layer.on text{ transform: scale(1.055); }

    /* floating callout follows mouse */
    .callout{
      position:absolute;
      min-width: 260px;
      max-width: 380px;
      padding: 14px 14px 12px;
      border-radius: 18px;
      background: var(--card);
      border: 1px solid var(--stroke);
      box-shadow: 0 18px 40px rgba(0,0,0,.16);
      backdrop-filter: blur(7px);
      z-index:4;
      pointer-events:none;

      opacity:0;
      transform: translateY(10px);
      transition: opacity .14s ease, transform .14s ease;
    }
    .callout.on{
      opacity:1;
      transform: translateY(0);
    }
    .callout .row{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap: 10px;
      margin-bottom: 8px;
    }
    .callout .cn{
      font-size: 42px;
      font-weight: 900;
      line-height: 1;
      font-family: "LiSu","STLiti","KaiTi","STKaiti","FangSong","SimSun",serif;
    }
    .callout .meta{
      text-align:right;
      font-size: 12px;
      color: var(--muted);
      letter-spacing:.06em;
      text-transform: uppercase;
      line-height:1.2;
    }
    .callout .desc{
      font-size: 13.5px;
      line-height: 1.75;
      color: rgba(0,0,0,.78);
    }

    @media (max-width: 720px){
      .callout{ min-width: 220px; max-width: 86vw; }
      svg{ width:min(640px, 92vw); }
      .calligraphy{ font-size: 440px; }
    }
  </style>
</head>

<body>
  <div class="stage" id="stage">
    <canvas id="bg"></canvas>
    <div class="paperOverlay"></div>

    <div class="topline">
      <div><b>Ink Study</b> · battlefield wash (animated)</div>
      <div>Hover the character · 战</div>
    </div>

    <div class="center">
      <svg id="svg" viewBox="0 0 1000 700" role="img" aria-label="Interactive Chinese character: 战">
        <defs>
          <!-- watery edge -->
          <filter id="inkWash" x="-20%" y="-20%" width="140%" height="140%">
            <feTurbulence type="fractalNoise" baseFrequency="0.012" numOctaves="2" seed="7" result="noise"/>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="10" xChannelSelector="R" yChannelSelector="G"/>
            <feGaussianBlur stdDeviation="0.55" />
          </filter>

          <!-- ink gradients (feel free to tweak colors) -->
          <radialGradient id="washWarm" cx="42%" cy="35%" r="78%">
            <stop offset="0%" stop-color="rgba(40,40,40,.92)"/>
            <stop offset="55%" stop-color="rgba(10,10,10,.58)"/>
            <stop offset="100%" stop-color="rgba(10,10,10,.18)"/>
          </radialGradient>
          <radialGradient id="washCold" cx="58%" cy="40%" r="85%">
            <stop offset="0%" stop-color="rgba(25,25,25,.90)"/>
            <stop offset="65%" stop-color="rgba(10,10,10,.52)"/>
            <stop offset="100%" stop-color="rgba(10,10,10,.16)"/>
          </radialGradient>

          <!-- organic clip regions (stylized “ink clouds”) -->
          <clipPath id="clip-bu">
            <path d="M235,150
                     C280,95 365,85 420,120
                     C450,92 520,98 545,150
                     C595,180 585,255 535,275
                     C520,335 440,350 395,320
                     C330,345 255,300 245,245
                     C210,220 205,175 235,150Z"/>
          </clipPath>

          <clipPath id="clip-kou">
            <path d="M245,385
                     C285,340 365,335 415,365
                     C455,340 525,360 540,410
                     C595,450 575,545 515,560
                     C495,625 415,635 375,600
                     C315,625 250,590 245,530
                     C210,500 205,420 245,385Z"/>
          </clipPath>

          <clipPath id="clip-ge">
            <path d="M520,165
                     C595,125 720,145 770,215
                     C835,255 835,355 790,395
                     C830,460 805,575 720,595
                     C665,640 560,620 535,545
                     C485,520 485,210 520,165Z"/>
          </clipPath>
        </defs>

        <!-- base -->
        <text x="500" y="560" text-anchor="middle" class="calligraphy ink-base">战</text>

        <!-- overlays -->
        <g id="layer-bu" class="layer" clip-path="url(#clip-bu)">
          <text x="500" y="560" text-anchor="middle" class="calligraphy"
                style="--ox: 360px; --oy: 230px; fill:url(#washWarm); filter:url(#inkWash);">战</text>
        </g>

        <g id="layer-kou" class="layer" clip-path="url(#clip-kou)">
          <text x="500" y="560" text-anchor="middle" class="calligraphy"
                style="--ox: 360px; --oy: 520px; fill:url(#washCold); filter:url(#inkWash);">战</text>
        </g>

        <g id="layer-ge" class="layer" clip-path="url(#clip-ge)">
          <text x="500" y="560" text-anchor="middle" class="calligraphy"
                style="--ox: 690px; --oy: 410px; fill:url(#washWarm); filter:url(#inkWash);">战</text>
        </g>
      </svg>
    </div>

    <!-- mouse-following callout -->
    <div class="callout" id="callout" aria-live="polite">
      <div class="row">
        <div class="cn" id="cn">战</div>
        <div class="meta" id="meta">overview</div>
      </div>
      <div class="desc" id="desc">
        Move across the character to reveal components. Chinese appears only for the character/parts.
      </div>
    </div>
  </div>

  <script>
    // -----------------------------
    // 1) Background: animated ink battlefield painting (canvas)
    // -----------------------------
    const canvas = document.getElementById("bg");
    const ctx = canvas.getContext("2d", { alpha: true });

    function resizeCanvas(){
      const r = canvas.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      canvas.width = Math.floor(r.width * dpr);
      canvas.height = Math.floor(r.height * dpr);
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // lightweight smooth noise
    function hash2(x, y){
      let n = x * 374761393 + y * 668265263;
      n = (n ^ (n >> 13)) * 1274126177;
      return ((n ^ (n >> 16)) >>> 0) / 4294967295;
    }
    function lerp(a,b,t){ return a + (b-a)*t; }
    function smoothstep(t){ return t*t*(3-2*t); }
    function valueNoise(x, y){
      const x0 = Math.floor(x), y0 = Math.floor(y);
      const xf = x - x0, yf = y - y0;
      const r00 = hash2(x0, y0);
      const r10 = hash2(x0+1, y0);
      const r01 = hash2(x0, y0+1);
      const r11 = hash2(x0+1, y0+1);
      const u = smoothstep(xf), v = smoothstep(yf);
      return lerp(lerp(r00, r10, u), lerp(r01, r11, u), v);
    }
    function fbm(x, y){
      let sum = 0, amp = 0.55, freq = 0.010;
      for(let i=0;i<4;i++){
        sum += amp * valueNoise(x*freq, y*freq);
        freq *= 2.05;
        amp *= 0.55;
      }
      return sum;
    }

    function inkBlot(x, y, r, a){
      const g = ctx.createRadialGradient(x, y, 0, x, y, r);
      g.addColorStop(0, `rgba(0,0,0,${a})`);
      g.addColorStop(0.55, `rgba(0,0,0,${a*0.45})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      ctx.fillStyle = g;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI*2);
      ctx.fill();
    }

    function drawMountains(w, h, t){
      // distant ridge
      ctx.save();
      ctx.globalCompositeOperation = "multiply";
      ctx.fillStyle = "rgba(0,0,0,0.08)";
      ctx.beginPath();
      ctx.moveTo(0, h*0.52);
      for(let x=0;x<=w;x+=20){
        const n = fbm(x + t*18, 30);
        const y = h*0.44 + n * 120;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();

      // mid ridge darker
      ctx.fillStyle = "rgba(0,0,0,0.12)";
      ctx.beginPath();
      ctx.moveTo(0, h*0.62);
      for(let x=0;x<=w;x+=18){
        const n = fbm(x + t*26, 90);
        const y = h*0.56 + n * 140;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(w, h);
      ctx.lineTo(0, h);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function drawSmoke(w, h, t){
      ctx.save();
      ctx.globalCompositeOperation = "multiply";
      for(let i=0;i<22;i++){
        const x = (w*0.15) + (i/22)*w*0.75 + Math.sin(t*0.35 + i)*16;
        const y = h*0.35 + Math.cos(t*0.28 + i*1.7)*14;
        const r = 80 + (i%5)*14;
        const a = 0.03 + (i%4)*0.008;
        inkBlot(x, y, r, a);
      }
      ctx.restore();
    }

    function drawBattleSilhouettes(w, h, t){
      ctx.save();
      ctx.globalCompositeOperation = "multiply";

      // ground haze
      ctx.fillStyle = "rgba(0,0,0,0.05)";
      ctx.fillRect(0, h*0.70, w, h*0.30);

      // tiny “army lines”
      ctx.strokeStyle = "rgba(0,0,0,0.18)";
      ctx.lineWidth = 1;
      for(let row=0; row<4; row++){
        const y = h*(0.72 + row*0.04) + Math.sin(t*0.6 + row)*2;
        ctx.beginPath();
        for(let x=0; x<=w; x+=14){
          const jitter = (fbm(x + row*200, t*40)*2 - 1) * 2.0;
          ctx.moveTo(x, y + jitter);
          ctx.lineTo(x, y + 4 + jitter);
        }
        ctx.stroke();
      }

      // flags & spears (suggestive, not literal)
      function flag(x,y,s){
        ctx.strokeStyle = "rgba(0,0,0,0.22)";
        ctx.lineWidth = 1.2;
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x, y - 22*s);
        ctx.stroke();

        ctx.fillStyle = "rgba(0,0,0,0.18)";
        ctx.beginPath();
        ctx.moveTo(x, y - 22*s);
        ctx.quadraticCurveTo(x + 16*s, y - 20*s, x + 18*s, y - 12*s);
        ctx.quadraticCurveTo(x + 16*s, y - 8*s, x, y - 10*s);
        ctx.closePath();
        ctx.fill();
      }

      const baseY = h*0.68;
      for(let i=0;i<10;i++){
        const x = w*(0.18 + i*0.07) + Math.sin(t*0.4 + i)*6;
        const y = baseY + (i%3)*10 + Math.cos(t*0.3 + i)*2;
        flag(x,y, 0.9 + (i%4)*0.07);
      }

      // cavalry hints (simple arcs)
      ctx.strokeStyle = "rgba(0,0,0,0.16)";
      ctx.lineWidth = 2;
      for(let i=0;i<6;i++){
        const x = w*(0.22 + i*0.12) + Math.sin(t*0.35 + i)*8;
        const y = h*(0.78 + (i%2)*0.02);
        ctx.beginPath();
        ctx.arc(x, y, 12, Math.PI*1.1, Math.PI*1.95);
        ctx.stroke();
      }

      ctx.restore();
    }

    function drawInkFlow(w, h, t){
      // very subtle animated wash across the whole paper
      ctx.save();
      ctx.globalCompositeOperation = "multiply";
      const step = 18;
      for(let y=0; y<h; y+=step){
        for(let x=0; x<w; x+=step){
          const n = fbm(x + t*22, y + t*14);
          const a = (n - 0.35) * 0.06; // super subtle
          if(a > 0){
            ctx.fillStyle = `rgba(0,0,0,${a})`;
            ctx.fillRect(x, y, step, step);
          }
        }
      }
      ctx.restore();
    }

    let start = performance.now();
    function animate(){
      const now = performance.now();
      const t = (now - start) / 1000;

      const r = canvas.getBoundingClientRect();
      const w = r.width, h = r.height;

      ctx.clearRect(0,0,w,h);

      // base wash
      ctx.save();
      ctx.fillStyle = "rgba(255,255,255,0.08)";
      ctx.fillRect(0,0,w,h);
      ctx.restore();

      // painting layers
      drawInkFlow(w,h,t*0.20);
      drawMountains(w,h,t*0.22);
      drawSmoke(w,h,t*0.26);
      drawBattleSilhouettes(w,h,t*0.30);

      requestAnimationFrame(animate);
    }

    window.addEventListener("resize", () => {
      resizeCanvas();
    });

    resizeCanvas();
    animate();

    // -----------------------------
    // 2) Foreground interaction: hover parts + mouse-following callout
    // -----------------------------
    const stage = document.getElementById("stage");
    const svg = document.getElementById("svg");

    const layer = {
      bu: document.getElementById("layer-bu"),
      kou: document.getElementById("layer-kou"),
      ge: document.getElementById("layer-ge"),
    };

    const callout = document.getElementById("callout");
    const cn = document.getElementById("cn");
    const meta = document.getElementById("meta");
    const desc = document.getElementById("desc");

    const DATA = {
      idle: {
        cn: "战",
        meta: "overview",
        desc:
          "This page pairs an animated ink battlefield with a structural reading of 战. " +
          "Hover different areas to reveal components: left 占 (卜/⺊ + 口) and right 戈. " +
          "Chinese appears only for the character and its parts."
      },
      bu: {
        cn: "卜",
        meta: "left-top component (within 占)",
        desc:
          "卜/⺊ appears historically in contexts related to divination or indication. " +
          "Here it stands for the left-top structural component of 战 (as part of 占)."
      },
      kou: {
        cn: "口",
        meta: "left-bottom component (within 占)",
        desc:
          "口 often relates to mouth/speech or an enclosure-like form. " +
          "Here it stands for the left-bottom structural component of 战 (as part of 占)."
      },
      ge: {
        cn: "戈",
        meta: "right component (weapon / conflict cue)",
        desc:
          "戈 is a weapon component and commonly signals meanings tied to conflict or force. " +
          "In 战, it forms the right-side structure and acts as a strong semantic clue."
      }
    };

    function clearLayers(){
      Object.values(layer).forEach(g => g.classList.remove("on"));
    }
    function setState(key){
      const d = DATA[key] || DATA.idle;
      cn.textContent = d.cn;
      meta.textContent = d.meta;
      desc.textContent = d.desc;

      if(key === "idle"){
        callout.classList.remove("on");
      }else{
        callout.classList.add("on");
      }
    }

    function getSvgPercent(evt){
      const r = svg.getBoundingClientRect();
      const x = (evt.clientX - r.left) / r.width;
      const y = (evt.clientY - r.top) / r.height;
      return { x: Math.min(Math.max(x,0),1), y: Math.min(Math.max(y,0),1) };
    }

    function regionFromPercent(p){
      const inside = (p.x > 0.18 && p.x < 0.84 && p.y > 0.12 && p.y < 0.92);
      if(!inside) return "idle";
      if(p.x < 0.49){
        return (p.y < 0.52) ? "bu" : "kou";
      }
      return "ge";
    }

    function positionCallout(evt){
      const s = stage.getBoundingClientRect();
      const pad = 16;

      const offsetX = (evt.clientX < s.left + s.width/2) ? 22 : -22;
      const offsetY = (evt.clientY < s.top + s.height/2) ? 18 : -18;

      let x = evt.clientX - s.left + offsetX;
      let y = evt.clientY - s.top + offsetY;

      const w = callout.offsetWidth || 320;
      const h = callout.offsetHeight || 160;

      x = Math.max(pad, Math.min(x, s.width - w - pad));
      y = Math.max(pad + 44, Math.min(y, s.height - h - pad)); // avoid top caption

      callout.style.left = `${x}px`;
      callout.style.top  = `${y}px`;
    }

    let last = "idle";
    setState("idle");

    svg.addEventListener("pointermove", (evt) => {
      positionCallout(evt);

      const p = getSvgPercent(evt);
      const key = regionFromPercent(p);
      if(key === last) return;

      clearLayers();
      if(key !== "idle"){
        layer[key].classList.add("on");
        setState(key);
      }else{
        setState("idle");
      }
      last = key;
    });

    svg.addEventListener("pointerleave", () => {
      clearLayers();
      setState("idle");
      last = "idle";
    });
  </script>
</body>
</html>