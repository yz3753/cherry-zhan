<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Ink Character · 战</title>
  <link rel="stylesheet" href="styles.css">
</head>

<body>
  <div class="stage" id="stage">
    <div class="bgimg"></div>
    <canvas id="wash"></canvas>
    <div class="paperOverlay"></div>

    <div class="topline">
      <div><b>Ink Study</b> · 战</div>
      <div>Hover the character</div>
    </div>

    <div class="center">
      <svg id="svg" viewBox="0 0 1000 700" role="img" aria-label="Interactive Chinese character: 战">
        <defs>
          <!-- Brush edge filter: roughen + feather -->
          <filter id="brushEdge" x="-25%" y="-25%" width="150%" height="150%">
            <feTurbulence type="fractalNoise" baseFrequency="0.014" numOctaves="2" seed="9" result="noise"/>
            <feDisplacementMap in="SourceGraphic" in2="noise" scale="14" xChannelSelector="R" yChannelSelector="G"/>
            <feGaussianBlur stdDeviation="0.45" />
          </filter>

          <!-- Stronger “bloom” for red highlight -->
          <filter id="redBloom" x="-35%" y="-35%" width="170%" height="170%">
            <feGaussianBlur stdDeviation="1.1" result="b"/>
            <feColorMatrix in="b" type="matrix"
              values="1 0 0 0 0
                      0 0.25 0 0 0
                      0 0 0.25 0 0
                      0 0 0 0.85 0" result="tinted"/>
            <feMerge>
              <feMergeNode in="tinted"/>
              <feMergeNode in="SourceGraphic"/>
            </feMerge>
          </filter>

          <!-- Non-highlight fade mask (radial, center moves with mouse) -->
          <!-- We animate cx/cy in JS by setting attributes on the gradient -->
          <radialGradient id="fadeGrad" cx="50%" cy="50%" r="72%">
            <stop offset="0%"   stop-color="white" stop-opacity="0.15"/>
            <stop offset="35%"  stop-color="white" stop-opacity="0.08"/>
            <stop offset="70%"  stop-color="white" stop-opacity="0.03"/>
            <stop offset="100%" stop-color="white" stop-opacity="0.00"/>
          </radialGradient>

          <mask id="fadeMask">
            <rect x="0" y="0" width="1000" height="700" fill="url(#fadeGrad)"/>
          </mask>

          <!-- Ink gradients for highlight -->
          <radialGradient id="redWash" cx="45%" cy="40%" r="80%">
            <stop offset="0%" stop-color="rgba(200,35,35,.98)"/>
            <stop offset="55%" stop-color="rgba(130,18,18,.70)"/>
            <stop offset="100%" stop-color="rgba(90,0,0,.20)"/>
          </radialGradient>

          <!-- Organic clip regions (same as before; can refine later with true glyph paths) -->
          <clipPath id="clip-bu">
            <path d="M235,150
                     C280,95 365,85 420,120
                     C450,92 520,98 545,150
                     C595,180 585,255 535,275
                     C520,335 440,350 395,320
                     C330,345 255,300 245,245
                     C210,220 205,175 235,150Z"/>
          </clipPath>

          <clipPath id="clip-kou">
            <path d="M245,385
                     C285,340 365,335 415,365
                     C455,340 525,360 540,410
                     C595,450 575,545 515,560
                     C495,625 415,635 375,600
                     C315,625 250,590 245,530
                     C210,500 205,420 245,385Z"/>
          </clipPath>

          <clipPath id="clip-ge">
            <path d="M520,165
                     C595,125 720,145 770,215
                     C835,255 835,355 790,395
                     C830,460 805,575 720,595
                     C665,640 560,620 535,545
                     C485,520 485,210 520,165Z"/>
          </clipPath>
        </defs>

        <!-- Base layer group: when hovering, it becomes faint + masked (gradient transparent) -->
        <g id="baseGroup" mask="url(#fadeMask)">
          <!-- “brush fill” made by stacking slightly offset copies -->
          <text x="500" y="575" text-anchor="middle" class="calligraphy"
                fill="rgba(10,10,10,.45)" filter="url(#brushEdge)">战</text>
          <text x="501" y="575" text-anchor="middle" class="calligraphy"
                fill="rgba(10,10,10,.38)" filter="url(#brushEdge)">战</text>
          <text x="499" y="576" text-anchor="middle" class="calligraphy"
                fill="rgba(10,10,10,.36)" filter="url(#brushEdge)">战</text>

          <!-- main ink -->
          <text x="500" y="575" text-anchor="middle" class="calligraphy"
                fill="rgba(10,10,10,.78)" filter="url(#brushEdge)">战</text>
        </g>

        <!-- Red highlight overlays (clipped) -->
        <g id="layer-bu" opacity="0" clip-path="url(#clip-bu)">
          <text x="500" y="575" text-anchor="middle" class="calligraphy"
                fill="url(#redWash)" filter="url(#redBloom)"
                style="transform-origin: 360px 230px; transform: scale(1);">战</text>
        </g>

        <g id="layer-kou" opacity="0" clip-path="url(#clip-kou)">
          <text x="500" y="575" text-anchor="middle" class="calligraphy"
                fill="url(#redWash)" filter="url(#redBloom)"
                style="transform-origin: 360px 520px; transform: scale(1);">战</text>
        </g>

        <g id="layer-ge" opacity="0" clip-path="url(#clip-ge)">
          <text x="500" y="575" text-anchor="middle" class="calligraphy"
                fill="url(#redWash)" filter="url(#redBloom)"
                style="transform-origin: 690px 410px; transform: scale(1);">战</text>
        </g>
      </svg>
    </div>

    <div class="callout" id="callout" aria-live="polite">
      <div class="row">
        <div class="cn" id="cn">战</div>
        <div class="meta" id="meta">overview</div>
      </div>
      <div class="desc" id="desc">
        Hover different areas to reveal components. Chinese appears only for the character/parts.
      </div>
    </div>
  </div>

  <script>
    // ----------------------------------------------------
    // A) Subtle animated ink wash on top of the background image
    // ----------------------------------------------------
    const wash = document.getElementById("wash");
    const wctx = wash.getContext("2d", { alpha:true });

    function resizeWash(){
      const r = wash.getBoundingClientRect();
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      wash.width = Math.floor(r.width * dpr);
      wash.height = Math.floor(r.height * dpr);
      wctx.setTransform(dpr,0,0,dpr,0,0);
    }

    function hash2(x,y){
      let n = x*374761393 + y*668265263;
      n = (n ^ (n>>13)) * 1274126177;
      return ((n ^ (n>>16))>>>0) / 4294967295;
    }
    const lerp=(a,b,t)=>a+(b-a)*t;
    const smooth=t=>t*t*(3-2*t);
    function noise(x,y){
      const x0=Math.floor(x), y0=Math.floor(y);
      const xf=x-x0, yf=y-y0;
      const r00=hash2(x0,y0), r10=hash2(x0+1,y0), r01=hash2(x0,y0+1), r11=hash2(x0+1,y0+1);
      const u=smooth(xf), v=smooth(yf);
      return lerp(lerp(r00,r10,u), lerp(r01,r11,u), v);
    }
    function fbm(x,y){
      let s=0, a=0.55, f=0.010;
      for(let i=0;i<4;i++){
        s += a*noise(x*f, y*f);
        f *= 2.05; a *= 0.55;
      }
      return s;
    }
    function blot(x,y,r,a){
      const g=wctx.createRadialGradient(x,y,0,x,y,r);
      g.addColorStop(0, `rgba(0,0,0,${a})`);
      g.addColorStop(0.6, `rgba(0,0,0,${a*0.35})`);
      g.addColorStop(1, `rgba(0,0,0,0)`);
      wctx.fillStyle=g;
      wctx.beginPath(); wctx.arc(x,y,r,0,Math.PI*2); wctx.fill();
    }

    let t0=performance.now();
    function animateWash(){
      const t=(performance.now()-t0)/1000;
      const r=wash.getBoundingClientRect();
      const W=r.width, H=r.height;

      wctx.clearRect(0,0,W,H);

      // sparse floating ink clouds
      wctx.globalCompositeOperation="multiply";
      for(let i=0;i<14;i++){
        const x = (W*0.10) + (i/14)*W*0.82 + Math.sin(t*0.25+i)*18;
        const y = H*(0.22 + 0.06*Math.sin(i*1.7)) + Math.cos(t*0.18+i*1.2)*14;
        blot(x,y, 110 + (i%4)*18, 0.020 + (i%3)*0.006);
      }

      // extremely subtle moving grain
      const step=22;
      for(let y=0;y<H;y+=step){
        for(let x=0;x<W;x+=step){
          const n=fbm(x+t*22, y+t*14);
          const a=(n-0.40)*0.05;
          if(a>0){
            wctx.fillStyle=`rgba(0,0,0,${a})`;
            wctx.fillRect(x,y,step,step);
          }
        }
      }

      requestAnimationFrame(animateWash);
    }

    window.addEventListener("resize", () => resizeWash());
    resizeWash();
    animateWash();

    // ----------------------------------------------------
    // B) Interaction: strong red highlight + base fades out (gradient transparent)
    // ----------------------------------------------------
    const stage = document.getElementById("stage");
    const svg = document.getElementById("svg");

    const baseGroup = document.getElementById("baseGroup");
    const fadeGrad = svg.querySelector("#fadeGrad"); // radialGradient element

    const layer = {
      bu: document.getElementById("layer-bu"),
      kou: document.getElementById("layer-kou"),
      ge: document.getElementById("layer-ge"),
    };

    const callout = document.getElementById("callout");
    const cn = document.getElementById("cn");
    const meta = document.getElementById("meta");
    const desc = document.getElementById("desc");

    const DATA = {
      idle: {
        cn: "战",
        meta: "overview",
        desc:
          "Hover different areas to reveal components: left 占 (卜/⺊ + 口) and right 戈. " +
          "Highlight turns red; the rest washes out into transparency."
      },
      bu: {
        cn: "卜",
        meta: "left-top component (within 占)",
        desc: "卜/⺊ appears historically in contexts related to divination or indication; here it marks the left-top structure in 战 (as part of 占)."
      },
      kou: {
        cn: "口",
        meta: "left-bottom component (within 占)",
        desc: "口 often relates to mouth/speech or an enclosure-like form; here it marks the left-bottom structure in 战 (as part of 占)."
      },
      ge: {
        cn: "戈",
        meta: "right component (weapon / conflict cue)",
        desc: "戈 is a weapon component and signals conflict/force; in 战 it forms the right-side structure and is a strong semantic cue."
      }
    };

    function clearLayers(){
      Object.values(layer).forEach(g => {
        g.style.opacity = "0";
        const txt = g.querySelector("text");
        txt.style.transform = "scale(1)";
      });
    }

    function setState(key){
      const d = DATA[key] || DATA.idle;
      cn.textContent = d.cn;
      meta.textContent = d.meta;
      desc.textContent = d.desc;

      if(key === "idle"){
        callout.classList.remove("on");
        baseGroup.style.opacity = "1";
      }else{
        callout.classList.add("on");
        baseGroup.style.opacity = "1"; // still shown but masked; opacity stays, mask handles fade
      }
    }

    function getSvgPercent(evt){
      const r = svg.getBoundingClientRect();
      const x = (evt.clientX - r.left) / r.width;
      const y = (evt.clientY - r.top) / r.height;
      return { x: Math.min(Math.max(x,0),1), y: Math.min(Math.max(y,0),1) };
    }

    function regionFromPercent(p){
      const inside = (p.x > 0.16 && p.x < 0.86 && p.y > 0.10 && p.y < 0.94);
      if(!inside) return "idle";
      if(p.x < 0.49) return (p.y < 0.52) ? "bu" : "kou";
      return "ge";
    }

    function positionCallout(evt){
      const s = stage.getBoundingClientRect();
      const pad = 16;

      const offsetX = (evt.clientX < s.left + s.width/2) ? 22 : -22;
      const offsetY = (evt.clientY < s.top + s.height/2) ? 18 : -18;

      let x = evt.clientX - s.left + offsetX;
      let y = evt.clientY - s.top + offsetY;

      const w = callout.offsetWidth || 320;
      const h = callout.offsetHeight || 160;

      x = Math.max(pad, Math.min(x, s.width - w - pad));
      y = Math.max(pad + 44, Math.min(y, s.height - h - pad));
      callout.style.left = `${x}px`;
      callout.style.top  = `${y}px`;
    }

    function moveFadeCenterToPointer(evt){
      // move radialGradient center (cx/cy) in % so non-highlight fades around the cursor area
      const r = svg.getBoundingClientRect();
      const px = (evt.clientX - r.left) / r.width;
      const py = (evt.clientY - r.top) / r.height;
      const cx = Math.round(Math.min(Math.max(px, 0), 1) * 100);
      const cy = Math.round(Math.min(Math.max(py, 0), 1) * 100);
      fadeGrad.setAttribute("cx", `${cx}%`);
      fadeGrad.setAttribute("cy", `${cy}%`);
    }

    let last="idle";
    setState("idle");

    svg.addEventListener("pointermove", (evt) => {
      positionCallout(evt);
      moveFadeCenterToPointer(evt);

      const p = getSvgPercent(evt);
      const key = regionFromPercent(p);
      if(key === last) return;

      clearLayers();
      if(key !== "idle"){
        // show & scale highlight strongly
        const g = layer[key];
        g.style.opacity = "1";
        const txt = g.querySelector("text");
        txt.style.transform = "scale(1.10)";  // stronger than before
        setState(key);
      }else{
        setState("idle");
      }
      last = key;
    });

    svg.addEventListener("pointerleave", () => {
      clearLayers();
      setState("idle");
      last="idle";
    });
  </script>
</body>
</html>